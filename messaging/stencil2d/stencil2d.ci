mainmodule stencil2d {
  readonly CProxy_Main main_proxy;
  readonly CProxy_Block block_proxy;
  readonly int grid_dim;
  readonly int block_x;
  readonly int block_y;
  readonly int n_chares_x;
  readonly int n_chares_y;
  readonly int n_iters;
  readonly int thread_coarsening;
  readonly bool unified_memory;

  mainchare Main {
    entry Main(CkArgMsg* m);
    entry [reductiontarget] void done();
  };

  array [2D] Block {
    entry Block(void);
    entry void init();
    entry void prepareGhostsDone(CkMessage* msg);
    entry void receiveGhosts(int ref, int dir, int w, double gh[w]);
    entry void processGhostsDone(CkMessage* msg);
    entry void updateDone(CkMessage* msg);
    entry void validateAndTerminate();

    entry void iterate() {
      serial {
        // Measure iteration time
        if (my_iter > 0) {
          total_time += CkWallTimer() - iter_start_time;
        }
        iter_start_time = CkWallTimer();

        if (my_iter >= n_iters) {
          // Terminate if all iterations are complete
          CkPrintf("[%4d] Average time per iteration: %.3lf us\n", thisFlatIndex,
              (total_time / n_iters) * 1000000);
          contribute(CkCallback(CkReductionTarget(Main, done), main_proxy));
        }
        else {
          // Prepare ghost regions for sending
          prepareGhosts();
        }
      }

      // Send ghosts once they are prepared
      when prepareGhostsDone[my_iter](const CkMessage* msg) serial {
        delete msg;
        sendGhosts();
      }

      // Receive ghost data from neighbors
      for (remote_count = 0; remote_count < neighbors; remote_count++) {
        when receiveGhosts[my_iter](int ref, int dir, int w, double buf[w]) serial {
          processGhosts(dir, w, buf);
        }
      }

      // Perform stencil computation once the ghost data are integrated
      when processGhostsDone[my_iter](const CkMessage* msg) serial {
        delete msg;
        update();
      }

      when updateDone[my_iter](const CkMessage* msg) serial {
        delete msg;

        if (my_iter == n_iters-1) {
          validateAndTerminate();
        }
        else {
          // Swap pointers
          double* tmp;
          if (!unified_memory) {
            tmp = d_temperature;
            d_temperature = d_new_temperature;
            d_new_temperature = tmp;
          }
          else {
            tmp = temperature;
            temperature = new_temperature;
            new_temperature = tmp;
          }

          my_iter++;
          thisProxy[thisIndex].iterate();
        }
      }
    };
  };
};
